# -*- coding: utf-8 -*-
"""Data Visualisation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e9ixocEJwVsUvsIfWqQNMtxTyoGoWBEt
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(color_codes=True)

"""#Tabulation"""

url = 'https://api.covid19india.org/states_daily.json'

import urllib.request

urllib.request.urlretrieve(url, 'data.json')

covid_data = pd.read_json('data.json')

covid_data

#load data as dictionary and manipulate the dictionary
import json

with open('data.json') as f:
    data = json.load(f)

data

data = data['states_daily']

covid_data = pd.json_normalize(data)

covid_data

#now tabulation

df = covid_data

df.data = pd.to_datetime(df.date)

df = df[df.status == 'Confirmed']

df.drop('status', axis=1, inplace = True)

df.set_index('date', inplace=True)

df

df.info()

df.tn

#object to integer
pd.to_numeric(df.tn)

df.info()

df.dtypes

df = df.apply(pd.to_numeric)

df = df.apply(pd.to_numeric)

df.info()

df.tail(7)

"""Styling Tabulated data......."""

df = df.tail(7)

df.style

#highlighting what ever number is negative....
def colour_red_negative(x):
    color = 'red' if x < 0 else 'white'
    return 'color:' + color

import pandas as pd

df.style.applymap(color_red_negative)

df.frop('un', axis=1, inplace=True)

df.style

df.style.highlight_max(color='red')

df.drop(['dd', 'ld'], axis=1, inplace = True)

df.style.highlight_max(color='red').highlight_min(color='green')

df.drop('tt', axis=1, inplace=True)

def bold_max_value(x):
    is_max = (x == x.max())
    return ['font-weight: bold' if y else '' for y in is_max]

df.style.apply(bold_max_value)

df.style.apply(bold_max_value).highlight_min(color='green')

df.style.apply(bold_max_value).highlight_max(color='red', axis=1)

df.style.background_gradient(cmap='Reds')

df.style.background_gradient(cmap='Reds', axis=1)

df.style.background_gradient(cmap='Reds',subset=['mh', 'tn', 'dl'])

df.style.bar()

df[['mh','dl','tn']].style.bar()

from pandas.io.formats.style import Styler

df[['mh', 'tn', 'dl']].style.bar(subset=['mh'], color='red').bar(subset=['tn'], color = 'orange').bar(subset=['dl'],color='yellow')

"""#Distribution of Data

#Distribution of a single continuous variable

#Histogram
"""

x = np.random.normal(size=1000)

sns.distplot(x);

sns.distplot(x, kde=False);

sns.set(color_codes=True)

sns.distplot(x, kde=False, rug=True)

sns.distplot(x, kde=False, rug=True, bins=50);

sns.kdeplot(x)

sns.kdeplot(x, shade=True);

y = np.random.uniform(size=1000)

sns.kdeplot(x,shade=True)
sns.kdeplot(y,shade=True);

d = sns.load_dataset('diamonds')

d

d.info()

sns.distplot(d.carat);

sns.distplot(d.price);

sns.distplot(d.x);

sns.distplot(d.x, rug=True)

sns.distplot(d.sample(1000).x, rug=True);

sns.distplot(d.sample(1000).x, rug=True, bins=40);

sns.kdeplot(d.x, shade = True)
sns.kdeplot(d.y, shade = True)
sns.kdeplot(d.z, shade = True);

"""#BoxPlot"""

x = np.random.normal(size=1000)

sns.boxplot(x)

x = np.random.uniform(size=1000)

sns.boxplot(x);

sns.boxplot(x, whis=0.2)

sns.boxplot(x, whis=0.5);

sns.boxplot(x, whis=0.5, fliersize=1, orient='v');

sns.boxplot(d.price);

sns.kdeplot(d.price);

sns.boxplot(d.x);

sns.displot(d.x);

sns.distplot(d.carat);

sns.boxplot(d.carat, orient='h')

"""#Distribution of a Categorical Variable

###Bar Plots
"""

c = d.groupby('cut')['cut'].count()

sns.barplot(x=c.index, y=c.values)

cl = d.groupby('clarity')['clarity'].count()
sns.barplot(x=cl.index, y=cl.values)

c = d.groupby('color')['color'].count()
sns.barplot(x=c.index, y=c.values);

"""### Joint Distribution of two variables......

#Joint Plot
"""

import numpy as np

x = np.random.normal(size=1000)
y = np.random.normal(size=1000)

df= pd.DataFrame({'x':x, 'y':y})

sns.jointplot(x='x',y='y', data=df);

sns.jointplot(x='x',y='y', data=df, kind='kde');

x = np.random.normal(size=1000)
y = 3 * x + np.random.normal(size=1000)/2

df = pd.DataFrame({'x':x, 'y':y})

sns.jointplot(x='x', y='y', data=df, kind='kde');

"""#Swarm Plot"""

sns.swarmplot(d.head(1000).carat)

sns.swarmplot(d.head(1000).price)

sns.swarmplot(d.sample(1000).price)

sns.swarmplot(d.sample(1000).carat)

d.info()

"""Multiple Swarm Plotting"""

sns.swarmplot(x='cut', y='price', data=d.sample(1000));

sns.swarmplot(x='clarity', y='price', data=d.sample(1000));

p = sns.load_dataset('penguins')

p

# prompt: Using dataframe p: swarmplot

import altair as alt
alt.Chart(p).mark_circle().encode(
    alt.X('species', title='Species'),
    alt.Y('bill_length_mm', title='Bill length (mm)'),
).properties(height=250, width=350)

sns.swarmplot(x='species', y='body_mass_g', data=p);

sns.swarmplot(x='island', y='body_mass_g', data=p);

"""#Violin Plot"""

sns.violinplot(x='body_mass_g', data=p);

sns.boxplot(x='body_mass_g', data=p)

sns.kdeplot(p.body_mass_g, shade=True)

# combining all these plots...............
sns.swarmplot(x='body_mass_g', data=p);
sns.violinplot(x='body_mass_g', data=p);
sns.boxplot(x='body_mass_g', data=p);
sns.kdeplot(p.body_mass_g, shade=True);

# combining all these plots...............
fig, axs = plt.subplots(nrows=4)
sns.swarmplot(x='body_mass_g', data=p, ax=axs[0]);
sns.violinplot(x='body_mass_g', data=p, ax=axs[1]);
sns.boxplot(x='body_mass_g', data=p, ax=axs[2]);
sns.kdeplot(p.body_mass_g, shade=True, ax=axs[3]);

# combining all these plots...............
fig, axs = plt.subplots(nrows=4)
fig.set_size_inches(5, 10)
sns.swarmplot(x='body_mass_g', data=p, ax=axs[0]);
sns.violinplot(x='body_mass_g', data=p, ax=axs[1]);
sns.boxplot(x='body_mass_g', data=p, ax=axs[2]);
sns.kdeplot(p.body_mass_g, shade=True, ax=axs[3]);

# combining all these plots...............
fig, axs = plt.subplots(nrows=4)
fig.set_size_inches(5, 10)
p1 = sns.swarmplot(x='body_mass_g', data=p, ax=axs[0]);
p1.set(xlim=(2000,7000));
p2 = sns.violinplot(x='body_mass_g', data=p, ax=axs[1]);
p2.set(xlim=(2000,7000));
p3 = sns.boxplot(x='body_mass_g', data=p, ax=axs[2]);
p3.set(xlim=(2000,7000));
p4 = sns.kdeplot(p.body_mass_g, shade=True, ax=axs[3]);
p4.set(xlim=(2000,7000));

"""#Multiple Violin Plots

"""

sns.violinplot(x='body_mass_g', data=p, orient='v');

sns.violinplot(x='species', y='body_mass_g', data=p);

sns.violinplot(x='species', y='flipper_length_mm', data=p);

sns.violinplot(x='species', y='island', data=p);

sns.violinplot(x='island', y='flipper_length_mm', data=p);

sns.swarmplot(x='island', y='flipper_length_mm', hue='sex', data=p);

sns.swarmplot(x='cut', y='price', hue='color', data=d.sample(1000));

"""#Paired Violin Plots"""

sns.violinplot(x='island', y='flipper_length_mm', data=p[p.sex=='MALE']);

sns.violinplot(x='island', y='flipper_length_mm', data=p[p.sex=='FEMALE']);

sns.violinplot(x='island', y='flipper_length_mm', hue='sex', split=True, data=p);

#gives moredescription about the mean, medain and inter-quartile range
sns.violinplot(x='island', y='flipper_length_mm', hue='sex', split=True, inner='quartile', data=p);

sns.violinplot(x='island', y='flipper_length_mm', hue='sex', data=p);

p['binary_species'] = p.species.apply(lambda x: 0 if x == 'Gentoo' else 1)

p

sns.violinplot(x='island', y='flipper_length_mm', hue='binary_species', split=True, inner='quartile', data=p);

"""#Faceted Plotting"""

sns.kdeplot(p.flipper_length_mm, shade = True)

sns.kdeplot(p[p.species == 'Gentoo'].flipper_length_mm, shade = True)

sns.kdeplot(p[p.species == 'Gentoo'].flipper_length_mm, shade = True)
sns.kdeplot(p[p.species == 'Adelie'].flipper_length_mm, shade = True)
sns.kdeplot(p[p.species == 'Chinstrap'].flipper_length_mm, shade = True)

sns.kdeplot(p[p.species == 'Gentoo'].flipper_length_mm, shade = True)
sns.kdeplot(p[p.species == 'Adelie'].flipper_length_mm, shade = True)
sns.kdeplot(p[p.species == 'Chinstrap'].flipper_length_mm, shade = True)
plt.legend(title='Species', labels=['Gentoo', 'Adelie', 'Chinstrap']);

sns.boxplot(p[p.species == 'Gentoo'].flipper_length_mm)
sns.boxplot(p[p.species == 'Adelie'].flipper_length_mm)
sns.boxplot(p[p.species == 'Chinstrap'].flipper_length_mm)
plt.legend(title='Species', labels=['Gentoo', 'Adelie', 'Chinstrap']);

fig, axs = plt.subplots(nrows=3);
sns.kdeplot(p[p.species == 'Gentoo'].flipper_length_mm, shade = True, ax=axs[0]);
sns.kdeplot(p[p.species == 'Adelie'].flipper_length_mm, shade = True, ax=axs[1]);
sns.kdeplot(p[p.species == 'Chinstrap'].flipper_length_mm, shade = True, ax=axs[2])
#plt.legend(title='Species', labels=['Gentoo', 'Adelie', 'Chinstrap']);

column_name = 'species'
nrows = len(p[column_name].unique())
fig, axs = plt.subplots(nrows=nrows);
i=0
for c_v in p[column_name].unique():
    pl = sns.kdeplot(p[p[column_name] == c_v].flipper_length_mm, shade=True, ax=axs[i]);
    pl.set_title(c_v);
    i += 1;
    plt.tight_layout()

# best way of doing it .........
g = sns.FacetGrid(p, row='species');
g.map(sns.kdeplot, 'flipper_length_mm', shade=True)

# best way of doing it .........
g = sns.FacetGrid(p, col='species');
g.map(sns.kdeplot, 'flipper_length_mm', shade=True)

"""#Pair Plot"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(color_codes=True)

p['binary_species'] = p.species.apply(lambda x: 0 if x == 'Gentoo' else 1)

sns.jointplot(p.body_mass_g, p.flipper_length_mm);

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
from matplotlib import style
plt.style.use(['dark_background'])

import urllib.request
import json

import seaborn as sns
sns.set(color_codes=True)

"""#Pie Chart"""

p = sns.load_dataset('penguins')

p.head()

p.groupby('species')['species'].count()

c = p.groupby('species')['species'].count()

plt.pie(c);
plt.show()

plt.pie(c, labels=c.index);
plt.show()

plt.pie(c, labels=c.index, autopct="%.2f%%");
plt.show()

plt.pie(c, labels=c.index, autopct="%.2f%%",
        explode=[0, 1, 0]);
plt.show()

plt.pie(c, labels=c.index, autopct="%.2f%%",
        explode=[0, 1, 0], startangle=180, shadow=True);
plt.show()

plt.pie(np.random.randint(0, 10, 10));
plt.show()

"""#Donut Chart"""

plt.pie(np.random.randint(0, 10, 10), wedgeprops=dict(width=0.3));
plt.show()

cmap = plt.get_cmap('Accent')
my_colours = cmap(np.arange(10))

plt.pie(np.random.randint(0, 10, 10),
        wedgeprops=dict(width=0.3),
        colors=my_colours);
plt.show()

plt.pie(c, labels=c.index, autopct="%.2f%%", wedgeprops=dict(width=0.3));
plt.show()

c_i = p.groupby('island')['island'].count()
plt.pie(c_i, labels=c_i.index, autopct="%.2f%%", wedgeprops=dict(width=0.3));
plt.show()

c = pd.crosstab(p.species, p.island)
c = c.T
c

plt.pie(c.sum(axis=1), labels=c.index,
        radius = 1, wedgeprops=dict(width=0.3));

plt.pie(c.sum(axis=1), labels=c.index,
        radius = 1, wedgeprops=dict(width=0.3));
plt.pie(c.values.flatten(), radius=0.7,
        wedgeprops=dict(width=0.3));

cmap = plt.get_cmap('tab20c')
outer_colors = cmap(np.array([0, 4, 8]))
inner_colors = cmap(np.array([1, 2, 3, 5, 6, 7, 9, 10, 11]))

plt.pie(c.sum(axis=1), labels=c.index,
        radius = 1, wedgeprops=dict(width=0.3),
        colors=outer_colors);
plt.pie(c.values.flatten(), radius=0.7,
        wedgeprops=dict(width=0.3),
        colors=inner_colors);

plt.pie(c.sum(axis=1), labels=c.index,
        radius = 1, wedgeprops=dict(width=0.3),
        colors=outer_colors);
plt.pie(c.values.flatten(), radius=0.7,
        labels = ['A', '', 'G', 'A', 'C', '', 'A', '', ''],
        wedgeprops=dict(width=0.3),
        colors=inner_colors);

plt.pie(c.sum(axis=1), labels=c.index,
        radius = 1, wedgeprops=dict(width=0.3),
        colors=outer_colors);
plt.pie(c.values.flatten(), radius=0.7,
        labels = ['A', '', 'G', 'A', 'C', '', 'A', '', ''],
        wedgeprops=dict(width=0.3),
        colors=inner_colors,
        labeldistance=0.75);

cmap = plt.get_cmap('tab20b')
outer_colors = cmap(np.array([0, 4, 8]))
inner_colors = cmap(np.array([1, 2, 3, 5, 6, 7, 9, 10, 11]))
plt.pie(c.sum(axis=1), labels=c.index,
        radius = 1, wedgeprops=dict(width=0.3),
        colors=outer_colors);
plt.pie(c.values.flatten(), radius=0.7,
        labels = ['A', '', 'G', 'A', 'C', '', 'A', '', ''],
        wedgeprops=dict(width=0.3),
        colors=inner_colors,
        labeldistance=0.75, textprops=dict(color='w'));

"""#Stacked Bar Plot"""

url = 'https://api.covid19india.org/states_daily.json'
urllib.request.urlretrieve(url, 'data.json')

with open('data.json') as f:
  data = json.load(f)
data = data['states_daily']
df = pd.json_normalize(data)

df.head()

df_ = df.tail(3)
df_.drop('date', axis=1, inplace=True)
df_.set_index('status', inplace=True)
df_ = df_.T
df_ = df_.apply(pd.to_numeric)
df_.drop('tt', inplace=True)

df_.head()

plt.bar(df_.index, df_.Confirmed);

plt.bar(df_.index, df_.Confirmed);
plt.xticks(rotation=90);

plt.bar(df_.index, df_.Confirmed);
plt.bar(df_.index, df_.Recovered, bottom=df_.Confirmed);
plt.xticks(rotation=90);

plt.bar(df_.index, df_.Confirmed);
plt.bar(df_.index, df_.Recovered, bottom=df_.Confirmed);
plt.bar(df_.index, df_.Deceased, bottom=df_.Confirmed + df_.Recovered);
plt.xticks(rotation=90);

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.bar(df_.index, df_.Confirmed);
plt.bar(df_.index, df_.Recovered, bottom=df_.Confirmed);
plt.bar(df_.index, df_.Deceased, bottom=df_.Confirmed + df_.Recovered);
plt.xticks(rotation=90);

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.bar(df_.index, df_.Confirmed, color='Orange');
plt.bar(df_.index, df_.Recovered, bottom=df_.Confirmed, color='Green');
plt.bar(df_.index, df_.Deceased, bottom=df_.Confirmed + df_.Recovered, color='Red');
plt.xticks(rotation=90);

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.bar(df_.index, df_.Confirmed, color='Orange');
plt.bar(df_.index, df_.Recovered, bottom=df_.Confirmed, color='Green');
plt.bar(df_.index, df_.Deceased, bottom=df_.Confirmed + df_.Recovered, color='Red');
plt.xticks(rotation=90);

for i, val in enumerate(df_.index):
    y = df_.loc[val].sum() + 100
    x = i
    plt.text(x, y, str(y), ha="center");

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.bar(df_.index, df_.Confirmed, color='Orange');
plt.bar(df_.index, df_.Recovered, bottom=df_.Confirmed, color='Green');
plt.bar(df_.index, df_.Deceased, bottom=df_.Confirmed + df_.Recovered, color='Red');
plt.xticks(rotation=90);

for i, val in enumerate(df_.index):
    y = df_.loc[val].sum() + 100
    if y > 1000:
        x = i
        plt.text(x, y, str(y), ha="center");

"""#Relative Stacked Bar Plots"""

df_.head()

df_['Total'] = 0

df_['Total'] = df_.sum(axis = 1)

df_.head()

df_['ConfirmedFraction'] = df_['Confirmed'] / df_['Total']
df_['RecoveredFraction'] = df_['Recovered'] / df_['Total']
df_['DeceasedFraction'] = df_['Deceased'] / df_['Total']

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.bar(df_.index, df_.ConfirmedFraction, color='Orange');
plt.bar(df_.index, df_.RecoveredFraction, bottom=df_.ConfirmedFraction, color='Green');
plt.bar(df_.index, df_.DeceasedFraction, bottom=df_.ConfirmedFraction + df_.RecoveredFraction, color='Red');
plt.xticks(rotation=90);

df_ = df_.sort_values('ConfirmedFraction', ascending=False)

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.bar(df_.index, df_.ConfirmedFraction, color='Orange');
plt.bar(df_.index, df_.RecoveredFraction, bottom=df_.ConfirmedFraction, color='Green');
plt.bar(df_.index, df_.DeceasedFraction, bottom=df_.ConfirmedFraction + df_.RecoveredFraction, color='Red');
plt.xticks(rotation=90);

import pandas as pd

"""#Time - Varying Composition of data

##Stacked area plot
"""

!pip install urllib
!pip show json

import urllib.request

import urllib.request
url = 'https://api.covid19india.org/states_daily.json'
urllib.request.urlretrieve(url, 'data.json')

with open('data.json') as f:
  data = json.load(f)
data = data['states_daily']
df = pd.json_normalize(data)

df.head()

df_ = df[['mh', 'date', 'status']]

df_.head()

df_['mh'] = pd.to_numeric(df_['mh'])
df_['date'] = pd.to_datetime(df_['date'])

df_.head()

"""date  |  confirmedrecovered   |  deceased  
2020-03-14 |  0  |  0

###Pivot - is used to transform something, across that particular point..
"""

##Syntax
df_ = df.pivot_table(values='mh', columns='status', index='date')

df_.head()

"""#Stacked area plot"""

df_.plot.area();

plt.stackplot(df_.index, df_.Confirmed, df_.Recovered, df_.Deceased);

fig = plt.gcf();
fig.set_size_inches(80,150);
plt.stackplot(df_.index, df_.Confirmed, df_.Recovered, df_.Deceased);

fig = plt.gcf();
fig.set_size_inches(80,50);
plt.stackplot(df_.index, df_.Confirmed, df_.Recovered, df_.Deceased,
              colors=['orange', 'green', 'red']);

fig = plt.gcf();
fig.set_size_inches(80,50);
plt.stackplot(df_.index, df_.Confirmed, df_.Recovered, df_.Deceased,
              labels=['Confirmed', 'Recovered', 'Deceased'],
              colors=['orange', 'green', 'red']);
plt.legend();

fig = plt.gcf();
fig.set_size_inches(15, 6);
plt.stackplot(df_.index, df_.Confirmed/df_.sum(axis=1),
              df_.Recovered/df_.sum(axis=1),
              df_.Deceased/df_.sum(axis=1),
              labels=['Confirmed', 'Recovered', 'Deceased'],
              colors=['orange', 'green', 'red']);
plt.legend();

def plot_stacked_area_by_state(state):
    df_ = df[[state, 'date', 'status']]
    df_[state] = pd.to_numeric(df_[state])
    df_['date'] = pd.to_datetime(df_['date'])
    df_ = df_.pivot_table(values=state, columns="status", index="date")
    fig = plt.gcf();
    fig.set_size_inches(15, 6);
    plt.stackplot(df_.index, df_.Confirmed/df_.sum(axis=1),
                df_.Recovered/df_.sum(axis=1),
                df_.Deceased/df_.sum(axis=1),
                labels=['Confirmed', 'Recovered', 'Deceased'],
                colors=['orange', 'green', 'red']);
    plt.legend();

"""#Plotting relationship between data

#Scatter Plots
"""

t = sns.load_dataset('tips')

t

t.head()

sns.scatterplot(x='total_bill', y='tip', data=t);

t['tip_fraction'] = t['tip']/t['total_bill']

sns.scatterplot(x='total_bill', y='tip_fraction', data=t)

sns.scatterplot(x='total_bill', y='tip', data=t, hue='time')

sns.scatterplot(x='total_bill', y='tip', data=t, hue='day')

sns.scatterplot(x='total_bill', y='tip', data=t, hue='size')

sns.scatterplot(x='total_bill', y='tip', data=t, hue='time', style='sex')

sns.scatterplot(x='total_bill', y='tip', data=t, hue='time', style='sex', size='size');

sns.scatterplot(x='total_bill', y='tip', data=t, hue='time', style='sex', size='size');
plt.legend(bbox_to_anchor=(1.05,1));

"""#Reg Plot"""

sns.regplot(x='total_bill', y='tip', data=t);

sns.regplot(x='total_bill', y='tip_fraction', data=t);

sns.regplot(x='total_bill', y='tip_fraction', data=t, marker='+');

d = sns.load_dataset('diamonds')

d.head()

sns.scatterplot(x='x', y='price', data=d.sample(1000));
#sns.scatterplot('x', 'price', data=d.sample(1000));

sns.regplot(x='x', y='price', data=d.sample(1000));

sns.regplot(x='x', y='price', data=d.sample(1000), order=2, marker='+');

"""#Bar Plot"""

!pip install seaborn

import seaborn as sns

sns.barplot(x="day", y="tip", data=t);

sns.barplot(x="day", y="tip_fraction", data=t);

#if i doesn't care about mean, instead  median.....
sns.barplot(x="day", y="tip", data=t, estimator=np.median);

def my_estimate(v):
    return np.quantile(v, 0.25);

#if we want our own function.....
sns.barplot(x="day", y="tip", data=t, estimator=my_estimate);

sns.barplot(x="day", y="tip", hue="sex", data=t, estimator=np.median);

sns.barplot(x="day", y="tip", hue="time", data=t, estimator=np.median);

#not much to say about tip_fraction......
sns.barplot(x="day", y="tip_fraction", hue="time", data=t, estimator=np.median);

"""#Continuous vs Continuous Plot"""

sns.barplot(x='price', data=d.sample(1000));

d.head()

sns.scatterplot(x='x', y='price', data=d.sample(1000));

sns.barplot(x='x', y='price', data=d.sample(1000));

d['x_q'] = pd.cut(d['x'], bins=15);

d.head()

sns.barplot(x='x_q', y='price', data=d.sample(1000));

d['x_q'] = pd.cut(d['x'], bins=15, labels=False);

sns.barplot(x='x_q', y='price', data=d.sample(1000));



"""#Line PLot"""

f = sns.load_dataset('fmri')

f.head()

sns.lineplot(x='timepoint', y='signal', data=f);

sns.lineplot(x='timepoint', y='signal', data=f, hue="region");

sns.lineplot(x='timepoint', y='signal', data=f, hue="event", style="region");

sns.lineplot(x='timepoint', y='signal', data=f, marker=True);

sns.lineplot(x='timepoint', y='signal', data=f, marker=True, estimator=np.median);

sns.lineplot(x='timepoint', y='signal', data=f, units='subject', estimator=None);

f_ = f[(f.region == "parietal") & (f.event == "cue")]

f_.head()

sns.lineplot(x='timepoint', y='signal', data=f_, units='subject', estimator=None);

x = np.array([-3, -2, -1, 0, 1, 2, 3])

y=x*x

sns.lineplot(x=x,y=y);

"""#Line Plot, Covid Data"""

!pip install json

import json

import urllib.request
url = 'https://api.covid19india.org/states_daily.json'
urllib.request.urlretrieve(url, 'data.json')

with open('data.json') as f:
  data = json.load(f)
data = data['states_daily']
df = pd.json_normalize(data)

with open('data.json') as f:
  data = json.load(f)
data = data['states_daily']
df = pd.json_normalize(data)
df['date'] = pd.to_datetime(df['date'])
df.drop('tt', axis=1, inplace=True)
df.set_index('date', inplace=True)
df = df[df['status'] == 'Confirmed']
df.drop('status', axis=1, inplace=True)
df = df.rolling(7).mean()
df.reset_index(inplace=True)

df.head()

df_ = pd.melt(df, id_vars="date",
              value_vars=list(df.columns).remove("date"),
              var_name = "state", value_name = "confirmed");

df_.head()

print(df_.head())

print('data' in df_.columns)

sns.lineplot(x='data', y='confirmed',hue="state", data=df_);

sns.lineplot(df_)

states=['mh', 'tn', 'dl', 'pb']

df_ = df_[df_.state.isin(states)]

sns.lineplot(x='date', y='confirmed', hue="state", data=df_);

fig = plt.gcf();
fig.set_size_inches(15,6);
sns.lineplot(x='date', y='confirmed', hue='state',
             data=df_, palette='Reds',
             hue_order=['ka','wb','gj','tn','mh']);

"""#Heat Maps

x[10 x 10]
x(i,j)->value
"""

x = np.random.rand(10,10)

x

sns.heatmap(x)

f = sns.load_dataset('flights')

f.head()

f.sample(10)

#applying pivot function
f_ = f.pivot(index='year', columns='month', values='passengers' );

f_.head()

sns.heatmap(f_)

sns.heatmap(f_.T)

sns.heatmap(f_.T, annot=True, fmt="d");

fig = plt.gcf();
fig.set_size_inches(15,10);
sns.heatmap(f_.T, annot=True, fmt="d");

fig = plt.gcf();
fig.set_size_inches(15,10);
sns.heatmap(f_.T, annot=True, fmt="d", cmap="YlGnBu");
# YlGnBu -> means color that is yellow,green,blue....

#defining our own colour.. by using sns.diverging_palette();
fig = plt.gcf();
fig.set_size_inches(15,10);
sns.heatmap(f_.T, annot=True, fmt="d",
            cmap=sns.diverging_palette(250,10,n=10));

#defining our own colour.. by using sns.diverging_palette();
fig= plt.gcf();
fig.set_size_inches(15,10);
sns.heatmap(f_.T, annot=True, fmt="d",
            cmap=sns.diverging_palette(250,10,n=50));fig
#diverging will give two color in both ends but white colour in
# middle section of plot........

#defining specific colour to the year 1957...
fig= plt.gcf();
fig.set_size_inches(15,10);
sns.heatmap(f_.T, annot=True, fmt="d",
            cmap=sns.diverging_palette(250,10,n=50),
            center=f_.loc[1957,'Jul']);
#here with july month all the comparision of colour is done.

fig= plt.gcf();
fig.set_size_inches(15,10);
sns.heatmap(f_.T, annot=True, fmt="d",
            cmap=sns.diverging_palette(250,10,n=50),
            center=f_.loc[1954,'Jan']);

"""#Opend-Ended Task"""

df = pd.read_excel('Census_Data_2011.xlsx')

df.head()

df

